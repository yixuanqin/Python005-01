# 学习笔记

## 类属性和对象属性
类的两大成员：属性和方法
#### 属性
- 类属性与对象属性
- 类属性字段在内存中只保存一份
- 对象属性在每个对象都保存一份

类的属性作用域
类的属性：
`_<name>` ：人为不可修改的属性，一般是内部属性或者中间属性，约定为不可修改
`__<name>` ：私有属性，python会自动改名，防止别人进行修改
`__<name>__` ：魔术方法，不会自动改名
双下划线开头和结尾的方法，实现了类的特殊成员，这类称作魔术方法
不是所有的双下划线开头和结尾的方法都是魔术方法
魔术方法类似其他语言的接口
```
# 显示object类的所有子类
print( ().__class__.__bases__[0].__subclasses__() )
```

## 类方法描述器
类的方法：
- 普通方法——至少一个 self 参数，表示该方法的对象
- 类方法——至少一个 cls 参数，表示该方法的类
- 静态方法——由类调用，无参数 

三种方法在内存中都归属于类
父类可以被子类继承，在父类中定义的classmethod，子类进行引用时，classmethod指定的类的名称就变成了子类？classmethod可以和子类的每个名称绑定
`classmethod` —— 构造函数，因为类自带的构造函数有且只有  __new__()  ，远不足以满足开发需求

什么时候使用 classmethod 
- 当函数调用时需要操作类
- 当类需要一系列构造函数时，定义在父类中，使用子类时可以引用


## 静态方法描述器
先定义好一个函数，使得该函数与类产生关系
可由类直接调用
不带`self`或者`cls`，不能用到类或者实例的属性；但可以传入参数
多数用于修饰功能转化的函数，比如类型的转化

## 描述器的高级应用`__getattribute__`和`__getattr__` 
在类中，需要对实例获取属性这一行为进行操作，可以使用： 
- `__getattribute__()`
- `__getattr__()`

异同： 
- 都可以对实例属性进行获取拦截
- `__getattr__()`适用于未定义的属性
- `__getattribute__()`对所有属性的访问都会调用该方法

## 描述器原理&&属性描述符
`@property`把描述器抽象化，可以把方法封装成属性，只读
被装饰函数建议使用相同的名称
使用`setter`并不能真正意义上实现无法写入，`gender`被改名为 `_Article__gender`
`property`本质并不是函数，而是特殊类（实现了数据描述符的类） 
如果一个对象同时定义了`__get__()`和`__set__()`方法，则称为数据描述符
如果仅定义了`__get__()`方法，则称为非数据描述符

property的优点： 
- 代码更简洁，可读性、可维护性更强。 
- 更好的管理属性的访问。 
- 控制属性访问权限，提高数据安全性。

## 面向对象编程——继承
新式类遵循广度优先，先在父类中寻找，按照父类声明顺序进行；如果父类没有，再到父类的父类查找

## solid的设计原则与设计模式&&单例模式
- 单一责任原则 The Single Responsibility Principle
    - 一个类仅有一个被修改的理由；如果有两件不同的事情导致类的属性/方法需要被修改，需要考虑拆分成两个类
    - 如果违反该原则，可能在调整某一模块功能时影响到其他模块的功能 
- 开放封闭原则 The Open Closed Principle
    - 一个类的拓展是开放的，类的修改是封闭的
    - 如果需要扩展某一个模块或者某一个类的功能时，不应该修改类里边的代码，而是应该在外面增加相应的功能
- 里氏替换原则 The Liskov Substitution Principle
    - 子类中的功能应该完全覆盖父类中的功能
    - 无需关心实例化后是从父类实例化的还是子类实例化的
    - 违反该原则可能导致无法识别对应的对象和属性，或产生无法预知的结果
- 依赖倒置原则 The Dependency Inversion Principle
    - 高层模块不应该依赖低层的模块
    - 可建立两个模块间的抽象，进行程序解耦
- 接口分离原则 The Interface Segregation Principle
    - 一个接口提供的方法是刚好满足需要的属性

#### 设计模式的作用
- 设计模式用于解决普遍性问题
- 设计模式保证结构的完整性

## 单例模式
程序实例化时只允许出现一个实例
`__init__` 和 `__new__` 的区别：
`__new__` 是实例创建之前被调用，返回该实例对象，是静态方法
`__init__` 是实例对象创建完成后被调用，是实例方法
`__new__` 先被调用，`__init__` 后被调用
`__new__` 的返回值（实例）将传递给 `__init__` 方法的第一个参数，`__init__` 给这个 实例设置相关参数

#### 如何创建单实例
- 使用装饰器，但不支持多线程
- 使用`__new__`，支持多线程，可以保证绝大部分情况下线程安全
- 使用`import`机制实现，将功能封装成模块，最安全且最保险

## 工厂模式
简单的工厂模式（静态工厂模式）：根据传入的不同参数，创建不同的实例
必备条件
1. 工厂角色：产生实例，判断传入的参数
2. 抽象产品角色：基类提供公共属性接口
3. 具体产品角色： 父类提供不同产品属性接口

### 动态创建类（类工厂模式）
通过函数返回值动态创建类
一般用于框架中

## 元类
元类是关于类的类，是类的模板
一般用于框架中
元类是用来控制如何创建类的，正如类是创建对象的模板一样
元类的实例为类，正如类的实例为对象
创建元类的两种方法 
- class
    - 创建类的时候指定元类`class DelDictValue(dict, metaclass == DelValue)`
    - 元类必须继承自type`class DelValue(type)`
    - 元类必须实现`__new__`
- type
    - type(类名，父类的元组(根据继承的需要，可以为空，包含属性的字典(名字和值))，类的成员)；定义函数/类时，如果只引用函数/类名称，表示引用该函数/类的对象；若引用函数名称()/类名称()，表示执行函数/实例化类

## 抽象基类
抽象基类（abstract base class，ABC）用来确保派生类实现了基类中的特定方法。
使用抽象基类的好处
- 避免继承错误，使类层次易于理解和维护
- 无法实例化基类
- 如果忘记在其中一个子类中实现接口方法，要尽早报错
```
from abc import ABC 
class MyABC(ABC): 
  pass 
MyABC.register(tuple) 
assert issubclass(tuple, MyABC) 
assert isinstance((), MyABC)
```

## mixin模式
在程序运行过程中，重定义类的继承，即动态继承。好处：
- 可以在不修改任何源代码的情况下，对已有类进行扩展
- 进行组件的划分
