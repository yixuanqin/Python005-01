# 学习笔记

## 为什么使用中间件 && 缓存的类别
### 为什么使用中间件？
- 随着用户量的增长，单体应用不足以支持用户访问。需要将应用进行拆分：应用 + 数据库。
- 数据库优化：1). 读写分离 2). 数据表的拆分
- 应用优化：将节点进行横向扩容
- 为了保证后端的不同节点对用户来说是透明的，需要采用中间存储介质保存应用程序的session，让后端处理请求时通过中间介质读取session。这个中间存储介质就是中间件。

### 中间件的类别
- 缓存
- 消息队列
- 队列
- 订阅和发布

### 企业级应用为什么需要缓存和消息队列？ 
- 随着业务规模扩大,单体应用不再满足业务场景需求
- 用户数量剧增,单凭数据库无法扛住并发压力
- 业务场景复杂需要解耦
- 业务场景丰富造成访问热点 ——> 缓存

## 缓存
- 使用内存开销，比数据库响应速度快(IO开销)
- 频繁被访问，但是极少修改的数据（热数据）适合放在缓存中
- 缓存分类
    - 本地缓存
    - 分布式缓存
- 缓存的差异
    - 本地缓存：使用本地内存，访问速度更快，受本机内存大小影响，一般是存放静态数据，比如配置文件
    - 分布式缓存：远程调用远端服务器，访问速度比本地缓存慢，资源易扩展，一般存放动态的全局的业务数据，用于业务模块间进行数据共享

### 缓存的同步方式
#### 缓存和数据库的交互
- 双写方式
    - 最简单，有数据写入时同时写入缓存和数据库，使用多线程，一般以数据库内数据为标准
    - 使用分布式事务，先写入数据库，再写入缓存
    - 写入数据库成功后再写入缓存
    - 写入缓存失败，可把数据库内数据同步到缓存中
    - 数据非常容易不一致
- 消息队列方式
    - 先写消息队列，再写缓存，适用于并发写入量较大的场景
    - 可降低数据不一致的概率，但是写入速度比双写的方式慢
    - 可以在消息队列做数据持久化，那么当写入消息队列成功时，就可更新缓存
- MySQL的binlog方式
    - 使用MySQL binlog重放写入缓存
    - 写入缓存最稳定的方式
    - 线性处理，binlog阻塞所有请求均会阻塞
三种方式：
- 均存在数据不一致的可能性
- 数据更新延迟：双写<消息队列<binlog
- 系统耦合度：双写>消息队列>binlog
- 复杂度：双写<消息队列<binlog

#### 缓存和应用程序的交互
- Cache Aside
    - 应用程序向缓存发起请求，查询是否有请求数据
    - 有，获取后直接返回给用户
    - 没有，从数据库获取，返回给用户，并写入缓存
    - 应用程序更新数据
    - 更新数据库，清除或更新缓存数据
    - 优缺点
        - 优点：实现简单，业务逻辑清晰
        - 缺点：更新缓存的逻辑写在业务代码里，开发人员必须了解缓存结构；更新策略需要自行维护
- Read/Write Through
    - 适合需要大量访问缓存的场景
    - 在业务逻辑和缓存间增加一个网关服务，把缓存和后端数据库视作整体
    - 优缺点：
        - 优点：编写业务逻辑时无需考虑是否存在缓存/数据库，无需在应用程序代码中维护缓存的更新逻辑
        - 缺点：但是需要单独维护缓存和数据库间的更新策略
- Write Back
    - 适合对数据一致性要求不高的场景
    - 将缓存和后端数据库视作整体，当作只有缓存服务。并且只修改缓存，不管数据库的更新；数据库的更新通过在缓存和数据库间新增消息队列解决，定期同步
    - 优缺点
        - 优点：对用户而言访问和返回数据非常及时
        - 缺点：写入数据库是异步的，可能出现数据丢失

### 缓存可能出现的问题
- 缓存穿透
    - 当请求没有放在缓存的数据时，会直接访问数据库。如果有人发现了这样的请求，并利用该请求触发人为的高并发的数据库访问时，容易造成数据库压力从而导致数据库访问故障
    - 如何解决：
        - 应用程序和数据库约定，如果获取的数据是空值或无法返回的，将该值也进行缓存
        - 最好设置比较短的超时时间，避免不必要的数据占用过大内存
        - 使用布隆过滤器， 设定过滤规则，将可能的数值尽可能包含在过滤规则内，但有误杀概率
- 缓存并发
    - 缓存的某一个key在某一时间点过期了，而在该时间点对这个key发起了大量并发请求，因为key过期了，所以会大量访问数据库
    - 如何解决：
        - 使用互斥锁：在缓存数据过期时，给该数据设置SETNX锁，再去请求数据库更新缓存数据
- 缓存雪崩
    - 大量key在相同时间点过期失效
    - 如何解决：
        - 添加随机事件分散key的过期时间
        - 使用多级缓存

## 安装 && 连接 Redis
- 特点
    - 使用 IO 多路复用机制
    - 监听多个文件描述符实现读写事件
    - 在6.0版本以前，是一个工作线程为单线程的应用；6.0之后可以开启多线程模式

- 安装
下载源代码，进行编译和安装
```
# 如果要在centos7中编译redis6.0，需要先将gcc版本升级到8.0
yum -y install centos-release-scl
yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils
scl enable devtoolset-9 bash
echo "source /opt/rh/devtoolset-9/enable" >> /etc/profile

# 编译命令
make && make install
```
配置
```
requirepass xxxxxxxx
bind 0.0.0.0
```
Python如何连接redis
```
pip3 install redis

client = redis.Redis(host = 'xx.xx.xx.xx', password = 'xxxxxx')
for key in client.keys():
  print(key.decode())
```

## Redis的基本数据结构
- 字符串
    - 最好控制在8字节内，编码方式：int(8字节以内) -> embstr(44字节以内)-> raw(超过44字节)
    - 同一个对象的编码方式只增不减
    - 可以用于记录用户名和用户id间的映射关系
    - 最好应用在小量级的访问，即访问次数在百万级别以下

- 列表
    - 一般用于做队列，支持左侧和右侧访问
    - 批量发送通知，把接受用户用列表方式存入redis，按照批量发送的最大值取用户进行发送；发送失败的用户重新加入列表左侧

- 集合
    - 集合没有顺序，集合内的元素不可重复
    - 从集合中取数据只能随机取
    - 支持交集、并集和差集的计算，常用于去重

- Hash
    - Hash基于hash表数据结构，查找速度不会因为数据量的增大而降低
    - Hash结构消耗的内存仅为字符串结构消耗内存的1/4，但是查询效率和字符串结构相同，因此常用于百万级别以上的映射关系存储
    - 无论hash中的key是否存在，使用命令hget的返回值永远是null，不能通过 return 判断是否取到值，而是要通过执行命令的结果进行判断
    - 使用hget或者hgetall的返回值都是bytes数据，需要进行decode转换为字符串

- 有序集合
    - 查询效率和数据量负相关
    - 用于集合的排序，用于常用于评分排序

## Redis的重要机制
- 缓存淘汰(数据的生存时间)
    - 目的
    - 节省空间
    - 保证数据的弱一致性
    - 清理方式
        - 定期清理：主动，定时的检查和清理
            - LRU：优先淘汰不是最近使用的数据，最常用
            - LFU：优先淘汰使用不频繁的数据，定期衰减
        - 惰性清理：被动，下次请求时再检查是否过期
- 主从复制
    - 主服务器支持读写，从服务器只读
    - 读取从服务器的默认机制是round-robin，可以加权
    - 支持一主多从，不支持多主多从
- 哨兵(sentinel)
    - 作用
        - 监控主从服务器是否在正确运行
        - 提醒，被监控的redis服务器出现问题时，可以通过API向管理员发起通知
        - 自动故障迁移，主服务器故障时自动将健康的从服务器升级为主服务器，并告诉客户端，并将故障服务器隔离
    - 多节点的哨兵，奇数节点，至少大于3
    - 哨兵仲裁的值加上存活哨兵的值需要能把故障节点投票出局；当所有子节点的权重为1时，哨兵权重至少为从节点数+1
    - 故障转移步骤
        - 检查主服务器的状态，主服务器客观下线
        - 哨兵组织选举
        - 按既定规则重新选择主服务器
        - 对比主服务器迁移时间：是否超过故障时间的两倍，超过的话重新选择
        - 选好新的主服务器后，哨兵向该服务器发送SLAVEOF NO ONE信号，新的主服务器上线
        - 通过订阅和发布功能把更新的配置通过哨兵同步到其他哨兵
        - 向故障服务器发送SLAVEOF信号，告诉该服务器要作为从服务器运行
        - 告诉其他从服务器新的主服务器信息
        - 通知客户端更换主服务器信息
        - 修改配置，持久化到本地

## 消息队列的用途
- 用途：
    - 异步处理 ：网购下单
    - 流量控制：令牌队列
    - 服务解耦：舆情系统，

- 消息队列的模型
    - 队列模型：先进先出
    - 发布-订阅模型：用于解耦

## RabbitMQ的主要结构
AMQP 协议与 RabbitMQ 软件
RabbitMQ 是 AMQP 的代理服务器
RabbitMQ 提供了一套严格的通信方式,通信的各个方面几乎都采用了远程过程调用 

#### 安装
```
yum install rabbitmq-server
rabbitmq-plugins enable rabbitmq_management

systemctl restart rabbitmq-server

# port
5672 -- service port
15672 -- web page
```

#### Queue
- 消息缓冲区
- 消费者从中消费，生产者生产消息存入

#### Channels
- 消费者/生产者与RabbitMQ通信的渠道
- 应用访问RabbitMQ通过建立TCP连接，建立连接后通过虚拟信道中的多线程进行通信
- 不建立多TCP连接是防止过多系统开销

#### Exchange
- direct：一对一的队列，一个生产者和一个消费者
- fanout：一对多，一个生产者和多个消费者；通过交换机绑定多个队列
- headers：不常用
- topic：多对一，多个交换机到一个队列

使用Channels建立连接，在连接中选择Exchange，再按需对接Queue


## 消息队列经常遇到的三个问题
- 如何保证事务在分布式消息队列的一致性?
    - 确认消息队列的类型
    - 使用分布式事务
- 如何保证消息不会丢?
    - 确认消息已收到后再删除
    - 接受者检查消息的序号
- 如何处理重复消息? 
    - 种类
        - 至多一次：传递消息至多送达一次
        - 最少一次：保证消息肯定能被收到，但是会有重复
        - 恰好一次：幂等性，利用数据库的唯一约束
## RPC和gRPC的使用
- 客户端访问服务器
- 两边使用相同的协议
- 通过TCP，效率高
- 传输二进制
- 解耦
- 必须经过网络
- 序列化和反序列化

